{
  "version": 3,
  "sources": ["../../.pnpm/webm-writer@1.0.0/node_modules/webm-writer/WebMWriter.js", "../../.pnpm/webm-writer@1.0.0/node_modules/webm-writer/ArrayBufferDataStream.js", "../../.pnpm/webm-writer@1.0.0/node_modules/webm-writer/BlobBuffer.js", "../../.pnpm/webm-writer@1.0.0/node_modules/webm-writer/browser.js"],
  "sourcesContent": ["/**\n * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n *\n * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n * eventually returned as one composite Blob.\n *\n * By Nicholas Sherlock.\n *\n * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function() {\n    function extend(base, top) {\n        let\n            target = {};\n        \n        [base, top].forEach(function(obj) {\n            for (let prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n        });\n        \n        return target;\n    }\n    \n    /**\n     * Decode a Base64 data URL into a binary string.\n     *\n     * @return {String} The binary string\n     */\n    function decodeBase64WebPDataURL(url) {\n        if (typeof url !== \"string\" || !url.match(/^data:image\\/webp;base64,/i)) {\n            throw new Error(\"Failed to decode WebP Base64 URL\");\n        }\n        \n        return window.atob(url.substring(\"data:image\\/webp;base64,\".length));\n    }\n    \n    /**\n     * Convert the given canvas to a WebP encoded image and return the image data as a string.\n     *\n     * @return {String}\n     */\n    function renderAsWebP(canvas, quality) {\n        let\n            frame = typeof canvas === 'string' && /^data:image\\/webp/.test(canvas)\n                ? canvas\n                : canvas.toDataURL('image/webp', quality);\n        \n        return decodeBase64WebPDataURL(frame);\n    }\n    \n    /**\n     * @param {String} string\n     * @returns {number}\n     */\n    function byteStringToUint32LE(string) {\n        let\n            a = string.charCodeAt(0),\n            b = string.charCodeAt(1),\n            c = string.charCodeAt(2),\n            d = string.charCodeAt(3);\n    \n        return (a | (b << 8) | (c << 16) | (d << 24)) >>> 0;\n    }\n    \n    /**\n     * Extract a VP8 keyframe from a WebP image file.\n     *\n     * @param {String} webP - Raw binary string\n     *\n     * @returns {{hasAlpha: boolean, frame: string}}\n     */\n    function extractKeyframeFromWebP(webP) {\n        let\n            cursor = webP.indexOf('VP8', 12); // Start the search after the 12-byte file header\n    \n        if (cursor === -1) {\n            throw new Error(\"Bad image format, does this browser support WebP?\");\n        }\n        \n        let\n            hasAlpha = false;\n    \n        /* Cursor now is either directly pointing at a \"VP8 \" keyframe, or a \"VP8X\" extended format file header\n         * Seek through chunks until we find the \"VP8 \" chunk we're interested in\n         */\n        while (cursor < webP.length - 8) {\n            let\n                chunkLength, fourCC;\n    \n            fourCC = webP.substring(cursor, cursor + 4);\n            cursor += 4;\n\n            chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));\n            cursor += 4;\n            \n            switch (fourCC) {\n                case \"VP8 \":\n                    return {\n                        frame: webP.substring(cursor, cursor + chunkLength),\n                        hasAlpha: hasAlpha\n                    };\n                    \n                case \"ALPH\":\n                    hasAlpha = true;\n                    /* But we otherwise ignore the content of the alpha chunk, since we don't have a decoder for it\n                     * and it isn't VP8-compatible\n                     */\n                    break;\n            }\n            \n            cursor += chunkLength;\n            \n            if ((chunkLength & 0x01) !== 0) {\n                cursor++;\n                // Odd-length chunks have 1 byte of trailing padding that isn't included in their length\n            }\n        }\n        \n        throw new Error(\"Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?\");\n    }\n    \n    const \n        EBML_SIZE_UNKNOWN = -1,\n        EBML_SIZE_UNKNOWN_5_BYTES = -2;\n    \n    // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n    function EBMLFloat32(value) {\n        this.value = value;\n    }\n    \n    function EBMLFloat64(value) {\n        this.value = value;\n    }\n    \n    /**\n     * Write the given EBML object to the provided ArrayBufferStream.\n     *\n     * @param buffer\n     * @param {Number} bufferFileOffset - The buffer's first byte is at this position inside the video file.\n     *                                    This is used to complete offset and dataOffset fields in each EBML structure,\n     *                                    indicating the file offset of the first byte of the EBML element and\n     *                                    its data payload.\n     * @param {*} ebml\n     */\n    function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n            for (let i = 0; i < ebml.length; i++) {\n                writeEBML(buffer, bufferFileOffset, ebml[i]);\n            }\n            // Is this some sort of raw data that we want to write directly?\n        } else if (typeof ebml === \"string\") {\n            buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n            buffer.writeBytes(ebml);\n        } else if (ebml.id){\n            // We're writing an EBML element\n            ebml.offset = buffer.pos + bufferFileOffset;\n            \n            buffer.writeUnsignedIntBE(ebml.id); // ID field\n            \n            // Now we need to write the size field, so we must know the payload size:\n            \n            if (Array.isArray(ebml.data)) {\n                // Writing an array of child elements. We won't try to measure the size of the children up-front\n                \n                let\n                    sizePos, dataBegin, dataEnd;\n                \n                if (ebml.size === EBML_SIZE_UNKNOWN) {\n                    // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n                    buffer.writeByte(0xFF);\n                } else if (ebml.size === EBML_SIZE_UNKNOWN_5_BYTES) {\n                    sizePos = buffer.pos;\n                    \n                    // VINT_DATA is all-ones, so this is the reserved \"unknown length\" marker:\n                    buffer.writeBytes([0x0F, 0xFF, 0xFF, 0xFF, 0xFF]);\n                } else {\n                    sizePos = buffer.pos;\n                    \n                    /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n\t\t\t\t\t * which should be plenty (we don't want to have to buffer that much data in memory at one time\n\t\t\t\t\t * anyway!)\n\t\t\t\t\t */\n                    buffer.writeBytes([0, 0, 0, 0]);\n                }\n                \n                dataBegin = buffer.pos;\n                \n                ebml.dataOffset = dataBegin + bufferFileOffset;\n                writeEBML(buffer, bufferFileOffset, ebml.data);\n                \n                if (ebml.size !== EBML_SIZE_UNKNOWN && ebml.size !== EBML_SIZE_UNKNOWN_5_BYTES) {\n                    dataEnd = buffer.pos;\n                    \n                    ebml.size = dataEnd - dataBegin;\n                    \n                    buffer.seek(sizePos);\n                    buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n                    \n                    buffer.seek(dataEnd);\n                }\n            } else if (typeof ebml.data === \"string\") {\n                buffer.writeEBMLVarInt(ebml.data.length); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeString(ebml.data);\n            } else if (typeof ebml.data === \"number\") {\n                // Allow the caller to explicitly choose the size if they wish by supplying a size field\n                if (!ebml.size) {\n                    ebml.size = buffer.measureUnsignedInt(ebml.data);\n                }\n                \n                buffer.writeEBMLVarInt(ebml.size); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n            } else if (ebml.data instanceof EBMLFloat64) {\n                buffer.writeEBMLVarInt(8); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeDoubleBE(ebml.data.value);\n            } else if (ebml.data instanceof EBMLFloat32) {\n                buffer.writeEBMLVarInt(4); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeFloatBE(ebml.data.value);\n            } else if (ebml.data instanceof Uint8Array) {\n                buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n                ebml.dataOffset = buffer.pos + bufferFileOffset;\n                buffer.writeBytes(ebml.data);\n            } else {\n                throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n            }\n        } else {\n            throw new Error(\"Bad EBML datatype \" + typeof ebml.data);\n        }\n    }\n    \n    /**\n     * @typedef {Object} Frame\n     * @property {string} frame - Raw VP8 keyframe data\n     * @property {string} alpha - Raw VP8 keyframe with alpha represented as luminance\n     * @property {Number} duration\n     * @property {Number} trackNumber - From 1 to 126 (inclusive)\n     * @property {Number} timecode\n     */\n    \n    /**\n     * @typedef {Object} Cluster\n     * @property {Number} timecode - Start time for the cluster\n     */\n    \n    /**\n     * @param ArrayBufferDataStream - Imported library\n     * @param BlobBuffer - Imported library\n     *\n     * @returns WebMWriter\n     *\n     * @constructor\n     */\n    let WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {\n        return function(options) {\n            let\n                MAX_CLUSTER_DURATION_MSEC = 5000,\n                DEFAULT_TRACK_NUMBER = 1,\n            \n                writtenHeader = false,\n                videoWidth = 0, videoHeight = 0,\n    \n                /**\n                 * @type {[HTMLCanvasElement]}\n                 */\n                alphaBuffer = null,\n\n                /**\n                 * @type {[CanvasRenderingContext2D]}\n                 */\n                alphaBufferContext = null,\n\n                /**\n                 * @type {[ImageData]}\n                 */\n                alphaBufferData = null,\n    \n                /**\n                 *\n                 * @type {Frame[]}\n                 */\n                clusterFrameBuffer = [],\n                clusterStartTime = 0,\n                clusterDuration = 0,\n                \n                optionDefaults = {\n                    quality: 0.95,       // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (WebP lossless) is not supported\n                    \n                    transparent: false,      // True if an alpha channel should be included in the video\n                    alphaQuality: undefined, // Allows you to set the quality level of the alpha channel separately.\n                                             // If not specified this defaults to the same value as `quality`.\n                    \n                    fileWriter: null,    // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n                    fd: null,            // Node.JS file descriptor to write to instead of buffering (optional)\n                    \n                    // You must supply one of:\n                    frameDuration: null, // Duration of frames in milliseconds\n                    frameRate: null,     // Number of frames per second\n                },\n                \n                seekPoints = {\n                    Cues: {id: new Uint8Array([0x1C, 0x53, 0xBB, 0x6B]), positionEBML: null},\n                    SegmentInfo: {id: new Uint8Array([0x15, 0x49, 0xA9, 0x66]), positionEBML: null},\n                    Tracks: {id: new Uint8Array([0x16, 0x54, 0xAE, 0x6B]), positionEBML: null},\n                },\n                \n                ebmlSegment, // Root element of the EBML document\n                \n                segmentDuration = {\n                    \"id\": 0x4489, // Duration\n                    \"data\": new EBMLFloat64(0)\n                },\n                \n                seekHead,\n                \n                cues = [],\n                \n                blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n    \n            function fileOffsetToSegmentRelative(fileOffset) {\n                return fileOffset - ebmlSegment.dataOffset;\n            }\n    \n            /**\n             * Extracts the transparency channel from the supplied canvas and uses it to create a VP8 alpha channel bitstream.\n             *\n             * @param {HTMLCanvasElement} source\n             *\n             * @return {HTMLCanvasElement}\n             */\n            function convertAlphaToGrayscaleImage(source) {\n                if (alphaBuffer === null || alphaBuffer.width !== source.width || alphaBuffer.height !== source.height) {\n                    alphaBuffer = document.createElement(\"canvas\");\n                    alphaBuffer.width = source.width;\n                    alphaBuffer.height = source.height;\n                    \n                    alphaBufferContext = alphaBuffer.getContext(\"2d\");\n                    alphaBufferData = alphaBufferContext.createImageData(alphaBuffer.width, alphaBuffer.height);\n                }\n                \n                let\n                    sourceContext = source.getContext(\"2d\"),\n                    sourceData = sourceContext.getImageData(0, 0, source.width, source.height).data,\n                    destData = alphaBufferData.data,\n                    dstCursor = 0,\n                    srcEnd = source.width * source.height * 4;\n                \n                for (let srcCursor = 3 /* Since pixel byte order is RGBA */; srcCursor < srcEnd; srcCursor += 4) {\n                    let\n                        alpha = sourceData[srcCursor];\n                    \n                    // Turn the original alpha channel into a brightness value (ends up being the Y in YUV)\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = alpha;\n                    destData[dstCursor++] = 255;\n                }\n                \n                alphaBufferContext.putImageData(alphaBufferData, 0, 0);\n                \n                return alphaBuffer;\n            }\n            \n            /**\n             * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n             *\n             * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n             * to be overwritten later.\n             */\n            function createSeekHead() {\n                let\n                    seekPositionEBMLTemplate = {\n                        \"id\": 0x53AC, // SeekPosition\n                        \"size\": 5, // Allows for 32GB video files\n                        \"data\": 0 // We'll overwrite this when the file is complete\n                    },\n                    \n                    result = {\n                        \"id\": 0x114D9B74, // SeekHead\n                        \"data\": []\n                    };\n                \n                for (let name in seekPoints) {\n                    let\n                        seekPoint = seekPoints[name];\n                \n                    seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n                    \n                    result.data.push({\n                         \"id\": 0x4DBB, // Seek\n                         \"data\": [\n                              {\n                                  \"id\": 0x53AB, // SeekID\n                                  \"data\": seekPoint.id\n                              },\n                              seekPoint.positionEBML\n                         ]\n                    });\n                }\n                \n                return result;\n            }\n            \n            /**\n             * Write the WebM file header to the stream.\n             */\n            function writeHeader() {\n                seekHead = createSeekHead();\n                \n                let\n                    ebmlHeader = {\n                        \"id\": 0x1a45dfa3, // EBML\n                        \"data\": [\n                            {\n                                \"id\": 0x4286, // EBMLVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f7, // EBMLReadVersion\n                                \"data\": 1\n                            },\n                            {\n                                \"id\": 0x42f2, // EBMLMaxIDLength\n                                \"data\": 4\n                            },\n                            {\n                                \"id\": 0x42f3, // EBMLMaxSizeLength\n                                \"data\": 8\n                            },\n                            {\n                                \"id\": 0x4282, // DocType\n                                \"data\": \"webm\"\n                            },\n                            {\n                                \"id\": 0x4287, // DocTypeVersion\n                                \"data\": 2\n                            },\n                            {\n                                \"id\": 0x4285, // DocTypeReadVersion\n                                \"data\": 2\n                            }\n                        ]\n                    },\n                    \n                    segmentInfo = {\n                        \"id\": 0x1549a966, // Info\n                        \"data\": [\n                            {\n                                \"id\": 0x2ad7b1, // TimecodeScale\n                                \"data\": 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n                            },\n                            {\n                                \"id\": 0x4d80, // MuxingApp\n                                \"data\": \"webm-writer-js\",\n                            },\n                            {\n                                \"id\": 0x5741, // WritingApp\n                                \"data\": \"webm-writer-js\"\n                            },\n                            segmentDuration // To be filled in later\n                        ]\n                    },\n                    \n                    videoProperties = [\n                        {\n                            \"id\": 0xb0, // PixelWidth\n                            \"data\": videoWidth\n                        },\n                        {\n                            \"id\": 0xba, // PixelHeight\n                            \"data\": videoHeight\n                        }\n                    ];\n                \n                if (options.transparent) {\n                    videoProperties.push(\n                        {\n                            \"id\": 0x53C0, // AlphaMode\n                            \"data\": 1\n                        }\n                    );\n                }\n                \n                let\n                    tracks = {\n                        \"id\": 0x1654ae6b, // Tracks\n                        \"data\": [\n                            {\n                                \"id\": 0xae, // TrackEntry\n                                \"data\": [\n                                    {\n                                        \"id\": 0xd7, // TrackNumber\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x73c5, // TrackUID\n                                        \"data\": DEFAULT_TRACK_NUMBER\n                                    },\n                                    {\n                                        \"id\": 0x9c, // FlagLacing\n                                        \"data\": 0\n                                    },\n                                    {\n                                        \"id\": 0x22b59c, // Language\n                                        \"data\": \"und\"\n                                    },\n                                    {\n                                        \"id\": 0x86, // CodecID\n                                        \"data\": \"V_VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x258688, // CodecName\n                                        \"data\": \"VP8\"\n                                    },\n                                    {\n                                        \"id\": 0x83, // TrackType\n                                        \"data\": 1\n                                    },\n                                    {\n                                        \"id\": 0xe0,  // Video\n                                        \"data\": videoProperties\n                                    }\n                                ]\n                            }\n                        ]\n                    };\n                \n                ebmlSegment = {\n                    \"id\": 0x18538067, // Segment\n                    \"size\": EBML_SIZE_UNKNOWN_5_BYTES, // We'll seek back and fill this in at completion\n                    \"data\": [\n                        seekHead,\n                        segmentInfo,\n                        tracks,\n                    ]\n                };\n                \n                let\n                    bufferStream = new ArrayBufferDataStream(256);\n                    \n                writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n                blobBuffer.write(bufferStream.getAsDataArray());\n                \n                // Now we know where these top-level elements lie in the file:\n                seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n                seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n                \n\t            writtenHeader = true;\n            }\n    \n            /**\n             * Create a BlockGroup element to hold the given keyframe (used when alpha support is required)\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A BlockGroup EBML element\n             */\n            function createBlockGroupForTransparentKeyframe(keyframe) {\n                let\n                    block, blockAdditions,\n                    \n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n    \n                // Create a Block to hold the image data:\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n        \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                bufferStream.writeByte(0); // Flags byte\n    \n                block = {\n                    \"id\": 0xA1, // Block\n                    \"data\": [\n                        bufferStream.getAsDataArray(),\n                        keyframe.frame\n                    ]\n                };\n    \n                blockAdditions = {\n                    \"id\": 0x75A1, // BlockAdditions\n                    \"data\": [\n                        {\n                            \"id\": 0xA6, // BlockMore\n                            \"data\": [\n                                {\n                                    \"id\": 0xEE, // BlockAddID\n                                    \"data\": 1   // Means \"BlockAdditional has a codec-defined meaning, pass it to the codec\"\n                                },\n                                {\n                                    \"id\": 0xA5, // BlockAdditional\n                                    \"data\": keyframe.alpha // The actual alpha channel image\n                                }\n                            ]\n                        }\n                    ]\n                };\n    \n                return {\n                    \"id\": 0xA0, // BlockGroup\n                    \"data\": [\n                        block,\n                        blockAdditions\n                    ]\n                };\n            }\n            \n            /**\n             * Create a SimpleBlock element to hold the given keyframe.\n             *\n             * @param {Frame} keyframe\n             *\n             * @return A SimpleBlock EBML element.\n             */\n            function createSimpleBlockForKeyframe(keyframe) {\n                let\n                    bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n                \n                if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n                    throw new Error(\"TrackNumber must be > 0 and < 127\");\n                }\n    \n                bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n                bufferStream.writeU16BE(keyframe.timecode);\n                \n                // Flags byte\n                bufferStream.writeByte(\n                    1 << 7 // Keyframe\n                );\n                \n                return {\n                    \"id\": 0xA3, // SimpleBlock\n                    \"data\": [\n                         bufferStream.getAsDataArray(),\n                         keyframe.frame\n                    ]\n                };\n            }\n    \n            /**\n             * Create either a SimpleBlock or BlockGroup (if alpha is required) for the given keyframe.\n             *\n             * @param {Frame} keyframe\n             */\n            function createContainerForKeyframe(keyframe) {\n                if (keyframe.alpha) {\n                    return createBlockGroupForTransparentKeyframe(keyframe);\n                }\n                \n                return createSimpleBlockForKeyframe(keyframe);\n            }\n        \n            /**\n             * Create a Cluster EBML node.\n             *\n             * @param {Cluster} cluster\n             *\n             * Returns an EBML element.\n             */\n            function createCluster(cluster) {\n                return {\n                    \"id\": 0x1f43b675,\n                    \"data\": [\n                         {\n                            \"id\": 0xe7, // Timecode\n                            \"data\": Math.round(cluster.timecode)\n                         }\n                    ]\n                };\n            }\n            \n            function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n                cues.push({\n                    \"id\": 0xBB, // Cue\n                    \"data\": [\n                         {\n                             \"id\": 0xB3, // CueTime\n                             \"data\": clusterTime\n                         },\n                         {\n                             \"id\": 0xB7, // CueTrackPositions\n                             \"data\": [\n                                  {\n                                      \"id\": 0xF7, // CueTrack\n                                      \"data\": trackIndex\n                                  },\n                                  {\n                                      \"id\": 0xF1, // CueClusterPosition\n                                      \"data\": fileOffsetToSegmentRelative(clusterFileOffset)\n                                  }\n                             ]\n                         }\n                    ]\n                });\n            }\n            \n            /**\n             * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n             * The seek entry for the Cues in the SeekHead is updated.\n             */\n            function writeCues() {\n                let\n                    ebml = {\n                        \"id\": 0x1C53BB6B,\n                        \"data\": cues\n                    },\n                    \n                    cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n                \n                writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n                blobBuffer.write(cuesBuffer.getAsDataArray());\n                \n                // Now we know where the Cues element has ended up, we can update the SeekHead\n                seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n            }\n            \n            /**\n             * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n             */\n            function flushClusterFrameBuffer() {\n                if (clusterFrameBuffer.length === 0) {\n                    return;\n                }\n    \n                // First work out how large of a buffer we need to hold the cluster data\n                let\n                    rawImageSize = 0;\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    rawImageSize += clusterFrameBuffer[i].frame.length + (clusterFrameBuffer[i].alpha ? clusterFrameBuffer[i].alpha.length : 0);\n                }\n                \n                let\n                    buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 64), // Estimate 64 bytes per block header\n    \n                    cluster = createCluster({\n                        timecode: Math.round(clusterStartTime),\n                    });\n                \n                for (let i = 0; i < clusterFrameBuffer.length; i++) {\n                    cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));\n                }\n                \n                writeEBML(buffer, blobBuffer.pos, cluster);\n                blobBuffer.write(buffer.getAsDataArray());\n                \n                addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n                \n                clusterFrameBuffer = [];\n                clusterStartTime += clusterDuration;\n                clusterDuration = 0;\n            }\n            \n            function validateOptions() {\n                // Derive frameDuration setting if not already supplied\n                if (!options.frameDuration) {\n                    if (options.frameRate) {\n                        options.frameDuration = 1000 / options.frameRate;\n                    } else {\n                        throw new Error(\"Missing required frameDuration or frameRate setting\");\n                    }\n                }\n                \n                // Avoid 1.0 (lossless) because it creates VP8L lossless frames that WebM doesn't support\n                options.quality = Math.max(Math.min(options.quality, 0.99999), 0);\n                \n                if (options.alphaQuality === undefined) {\n                    options.alphaQuality = options.quality;\n                } else {\n                    options.alphaQuality = Math.max(Math.min(options.alphaQuality, 0.99999), 0);\n                }\n            }\n    \n            /**\n             *\n             * @param {Frame} frame\n             */\n            function addFrameToCluster(frame) {\n                frame.trackNumber = DEFAULT_TRACK_NUMBER;\n                \n                // Frame timecodes are relative to the start of their cluster:\n                frame.timecode = Math.round(clusterDuration);\n    \n                clusterFrameBuffer.push(frame);\n                \n                clusterDuration += frame.duration;\n                \n                if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n                    flushClusterFrameBuffer();\n                }\n            }\n            \n            /**\n             * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n             *\n             * Call once writing is complete (so the offset of all top level elements is known).\n             */\n            function rewriteSeekHead() {\n                let\n                    seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n                    oldPos = blobBuffer.pos;\n                \n                // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n                writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);\n                \n                // And write that through to the file\n                blobBuffer.seek(seekHead.dataOffset);\n                blobBuffer.write(seekHeadBuffer.getAsDataArray());\n    \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n             */\n            function rewriteDuration() {\n                let\n                    buffer = new ArrayBufferDataStream(8),\n                    oldPos = blobBuffer.pos;\n                \n                // Rewrite the data payload (don't need to update the id or size)\n                buffer.writeDoubleBE(clusterStartTime);\n                \n                // And write that through to the file\n                blobBuffer.seek(segmentDuration.dataOffset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n    \n            /**\n             * Rewrite the size field of the Segment.\n             */\n            function rewriteSegmentLength() {\n                let\n                    buffer = new ArrayBufferDataStream(10),\n                    oldPos = blobBuffer.pos;\n    \n                // We just need to rewrite the ID and Size fields of the root Segment:\n                buffer.writeUnsignedIntBE(ebmlSegment.id);\n                buffer.writeEBMLVarIntWidth(blobBuffer.pos - ebmlSegment.dataOffset, 5);\n                \n                // And write that on top of the original:\n                blobBuffer.seek(ebmlSegment.offset);\n                blobBuffer.write(buffer.getAsDataArray());\n        \n                blobBuffer.seek(oldPos);\n            }\n            \n            /**\n             * Add a frame to the video.\n             *\n             * @param {HTMLCanvasElement|String} frame - A Canvas element that contains the frame, or a WebP string\n             *                                           you obtained by calling toDataUrl() on an image yourself.\n             *\n             * @param {HTMLCanvasElement|String} [alpha] - For transparent video, instead of including the alpha channel\n             *                                             in your provided `frame`, you can instead provide it separately\n             *                                             here. The alpha channel of this alpha canvas will be ignored,\n             *                                             encode your alpha information into this canvas' grayscale\n             *                                             brightness instead.\n             *\n             *                                             This is useful because it allows you to paint the colours\n             *                                             you need into your `frame` even in regions which are fully\n             *                                             transparent (which Canvas doesn't normally let you influence).\n             *                                             This allows you to control the colour of the fringing seen\n             *                                             around objects on transparent backgrounds.\n             *\n             * @param {Number} [overrideFrameDuration] - Set a duration for this frame (in milliseconds) that differs\n             *                                           from the default\n             */\n            this.addFrame = function(frame, alpha, overrideFrameDuration) {\n                if (!writtenHeader) {\n                    videoWidth = frame.width || 0;\n                    videoHeight = frame.height || 0;\n    \n                    writeHeader();\n                }\n    \n                let\n                    keyframe = extractKeyframeFromWebP(renderAsWebP(frame, options.quality)),\n                    frameDuration, frameAlpha = null;\n                \n                if (overrideFrameDuration) {\n                    frameDuration = overrideFrameDuration;\n                } else if (typeof alpha == \"number\") {\n                    frameDuration = alpha;\n                } else {\n                    frameDuration = options.frameDuration;\n                }\n                \n                if (options.transparent) {\n                    if (alpha instanceof HTMLCanvasElement || typeof alpha === \"string\") {\n                        frameAlpha = alpha;\n                    } else if (keyframe.hasAlpha) {\n                        frameAlpha = convertAlphaToGrayscaleImage(frame);\n                    }\n                }\n                \n                addFrameToCluster({\n                    frame: keyframe.frame,\n                    duration: frameDuration,\n                    alpha: frameAlpha ? extractKeyframeFromWebP(renderAsWebP(frameAlpha, options.alphaQuality)).frame : null\n                });\n            };\n            \n            /**\n             * Finish writing the video and return a Promise to signal completion.\n             *\n             * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n             * a Blob with the contents of the entire video.\n             */\n            this.complete = function() {\n            \tif (!writtenHeader) {\n\t\t            writeHeader();\n\t            }\n\t            \n                flushClusterFrameBuffer();\n                writeCues();\n                \n                /* \n                 * Now the file is at its final length and the position of all elements is known, seek back to the\n                 * header and update pointers:\n                 */\n                \n                rewriteSeekHead();\n                rewriteDuration();\n                rewriteSegmentLength();\n                \n                return blobBuffer.complete('video/webm');\n            };\n            \n            this.getWrittenSize = function() {\n                return blobBuffer.length;\n            };\n    \n            options = extend(optionDefaults, options || {});\n            validateOptions();\n        };\n    };\n    \n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t    module.exports = WebMWriter;\n    } else {\n\t    window.WebMWriter = WebMWriter(window.ArrayBufferDataStream, window.BlobBuffer);\n    }\n})();\n", "/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n\"use strict\";\n\n(function(){\n    /*\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n    let ArrayBufferDataStream = function(length) {\n        this.data = new Uint8Array(length);\n        this.pos = 0;\n    };\n    \n    ArrayBufferDataStream.prototype.seek = function(toOffset) {\n        this.pos = toOffset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function(arr) {\n        for (let i = 0; i < arr.length; i++) {\n            this.data[this.pos++] = arr[i];\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function(b) {\n        this.data[this.pos++] = b;\n    };\n    \n    //Synonym:\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n    \n    ArrayBufferDataStream.prototype.writeU16BE = function(u) {\n        this.data[this.pos++] = u >> 8;\n        this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function(d) {\n        let\n            bytes = new Uint8Array(new Float64Array([d]).buffer);\n        \n        for (let i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function(d) {\n        let\n            bytes = new Uint8Array(new Float32Array([d]).buffer);\n        \n        for (let i = bytes.length - 1; i >= 0; i--) {\n            this.writeByte(bytes[i]);\n        }\n    };\n\n    /**\n     * Write an ASCII string to the stream\n     */\n    ArrayBufferDataStream.prototype.writeString = function(s) {\n        for (let i = 0; i < s.length; i++) {\n            this.data[this.pos++] = s.charCodeAt(i);\n        }\n    };\n\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n     * (use measureEBMLVarInt).\n     *\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function(i, width) {\n        switch (width) {\n            case 1:\n                this.writeU8((1 << 7) | i);\n            break;\n            case 2:\n                this.writeU8((1 << 6) | (i >> 8));\n                this.writeU8(i);\n            break;\n            case 3:\n                this.writeU8((1 << 5) | (i >> 16));\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 4:\n                this.writeU8((1 << 4) | (i >> 24));\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            case 5:\n                /*\n                 * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n                 * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n                 */\n                this.writeU8((1 << 3) | ((i / 4294967296) & 0x7));\n                this.writeU8(i >> 24);\n                this.writeU8(i >> 16);\n                this.writeU8(i >> 8);\n                this.writeU8(i);\n            break;\n            default:\n                throw new Error(\"Bad EBML VINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function(val) {\n        if (val < (1 << 7) - 1) {\n            /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n             * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n             */\n            return 1;\n        } else if (val < (1 << 14) - 1) {\n            return 2;\n        } else if (val < (1 << 21) - 1) {\n            return 3;\n        } else if (val < (1 << 28) - 1) {\n            return 4;\n        } else if (val < 34359738367) { // 2 ^ 35 - 1 (can address 32GB)\n            return 5;\n        } else {\n            throw new Error(\"EBML VINT size not supported \" + val);\n        }\n    };\n    \n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function(i) {\n        this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    \n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * Omit the width parameter to have it determined automatically for you.\n     *\n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function(u, width) {\n        if (width === undefined) {\n            width = this.measureUnsignedInt(u);\n        }\n        \n        // Each case falls through:\n        switch (width) {\n            case 5:\n                this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var\n            case 4:\n                this.writeU8(u >> 24);\n            case 3:\n                this.writeU8(u >> 16);\n            case 2:\n                this.writeU8(u >> 8);\n            case 1:\n                this.writeU8(u);\n            break;\n            default:\n                throw new Error(\"Bad UINT size \" + width);\n        }\n    };\n    \n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function(val) {\n        // Force to 32-bit unsigned integer\n        if (val < (1 << 8)) {\n            return 1;\n        } else if (val < (1 << 16)) {\n            return 2;\n        } else if (val < (1 << 24)) {\n            return 3;\n        } else if (val < 4294967296) {\n            return 4;\n        } else {\n            return 5;\n        }\n    };\n\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n    ArrayBufferDataStream.prototype.getAsDataArray = function() {\n        if (this.pos < this.data.byteLength) {\n            return this.data.subarray(0, this.pos);\n        } else if (this.pos == this.data.byteLength) {\n            return this.data;\n        } else {\n            throw new Error(\"ArrayBufferDataStream's pos lies beyond end of buffer\");\n        }\n    };\n\t\n\tif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t\tmodule.exports = ArrayBufferDataStream;\n\t} else {\n\t\twindow.ArrayBufferDataStream = ArrayBufferDataStream;\n\t}\n}());", "\"use strict\";\n\n/**\n * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n * overwriting of blobs is allowed.\n *\n * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n * through to the disk.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n(function() {\n\tlet BlobBuffer = function(fs) {\n\t\treturn function(destination) {\n\t\t\tlet\n\t\t\t\tbuffer = [],\n\t\t\t\twritePromise = Promise.resolve(),\n\t\t\t\tfileWriter = null,\n\t\t\t\tfd = null;\n\t\t\t\n\t\t\tif (destination && destination.constructor.name === \"FileWriter\") {\n\t\t\t\tfileWriter = destination;\n\t\t\t} else if (fs && destination) {\n\t\t\t\tfd = destination;\n\t\t\t}\n\t\t\t\n\t\t\t// Current seek offset\n\t\t\tthis.pos = 0;\n\t\t\t\n\t\t\t// One more than the index of the highest byte ever written\n\t\t\tthis.length = 0;\n\t\t\t\n\t\t\t// Returns a promise that converts the blob to an ArrayBuffer\n\t\t\tfunction readBlobAsBuffer(blob) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tlet\n\t\t\t\t\t\treader = new FileReader();\n\t\t\t\t\t\n\t\t\t\t\treader.addEventListener(\"loadend\", function () {\n\t\t\t\t\t\tresolve(reader.result);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction convertToUint8Array(thing) {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tif (thing instanceof Uint8Array) {\n\t\t\t\t\t\tresolve(thing);\n\t\t\t\t\t} else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n\t\t\t\t\t\tresolve(new Uint8Array(thing));\n\t\t\t\t\t} else if (thing instanceof Blob) {\n\t\t\t\t\t\tresolve(readBlobAsBuffer(thing).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Assume that Blob will know how to read this thing\n\t\t\t\t\t\tresolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n\t\t\t\t\t\t\treturn new Uint8Array(buffer);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfunction measureData(data) {\n\t\t\t\tlet\n\t\t\t\t\tresult = data.byteLength || data.length || data.size;\n\t\t\t\t\n\t\t\t\tif (!Number.isInteger(result)) {\n\t\t\t\t\tthrow new Error(\"Failed to determine size of element\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t/**\n\t\t\t * Seek to the given absolute offset.\n\t\t\t *\n\t\t\t * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n\t\t\t * sequential order, which isn't currently supported by the memory buffer backend).\n\t\t\t */\n\t\t\tthis.seek = function (offset) {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tthrow new Error(\"Offset may not be negative\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (isNaN(offset)) {\n\t\t\t\t\tthrow new Error(\"Offset may not be NaN\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (offset > this.length) {\n\t\t\t\t\tthrow new Error(\"Seeking beyond the end of file is not allowed\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis.pos = offset;\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Write the Blob-convertible data to the buffer at the current seek position.\n\t\t\t *\n\t\t\t * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n\t\t\t * be fully contained by the extent of a previous write).\n\t\t\t */\n\t\t\tthis.write = function (data) {\n\t\t\t\tlet\n\t\t\t\t\tnewEntry = {\n\t\t\t\t\t\toffset: this.pos,\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\tlength: measureData(data)\n\t\t\t\t\t},\n\t\t\t\t\tisAppend = newEntry.offset >= this.length;\n\t\t\t\t\n\t\t\t\tthis.pos += newEntry.length;\n\t\t\t\tthis.length = Math.max(this.length, this.pos);\n\t\t\t\t\n\t\t\t\t// After previous writes complete, perform our write\n\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\tif (fd) {\n\t\t\t\t\t\treturn new Promise(function(resolve, reject) {\n\t\t\t\t\t\t\tconvertToUint8Array(newEntry.data).then(function(dataArray) {\n\t\t\t\t\t\t\t\tlet\n\t\t\t\t\t\t\t\t\ttotalWritten = 0,\n\t\t\t\t\t\t\t\t\tbuffer = Buffer.from(dataArray.buffer),\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\thandleWriteComplete = function(err, written, buffer) {\n\t\t\t\t\t\t\t\t\t\ttotalWritten += written;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif (totalWritten >= buffer.length) {\n\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// We still have more to write...\n\t\t\t\t\t\t\t\t\t\t\tfs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (fileWriter) {\n\t\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tfileWriter.onwriteend = resolve;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfileWriter.seek(newEntry.offset);\n\t\t\t\t\t\t\tfileWriter.write(new Blob([newEntry.data]));\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!isAppend) {\n\t\t\t\t\t\t// We might be modifying a write that was already buffered in memory.\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Slow linear search to find a block we might be overwriting\n\t\t\t\t\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tlet\n\t\t\t\t\t\t\t\tentry = buffer[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// If our new entry overlaps the old one in any way...\n\t\t\t\t\t\t\tif (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n\t\t\t\t\t\t\t\tif (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Overwrite crosses blob boundaries\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n\t\t\t\t\t\t\t\t\t// We overwrote the entire block\n\t\t\t\t\t\t\t\t\tentry.data = newEntry.data;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// We're done\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn convertToUint8Array(entry.data)\n\t\t\t\t\t\t\t\t\t\t.then(function (entryArray) {\n\t\t\t\t\t\t\t\t\t\t\tentry.data = entryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\treturn convertToUint8Array(newEntry.data);\n\t\t\t\t\t\t\t\t\t\t}).then(function (newEntryArray) {\n\t\t\t\t\t\t\t\t\t\t\tnewEntry.data = newEntryArray;\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tentry.data.set(newEntry.data, newEntry.offset - entry.offset);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbuffer.push(newEntry);\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t/**\n\t\t\t * Finish all writes to the buffer, returning a promise that signals when that is complete.\n\t\t\t *\n\t\t\t * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n\t\t\t * contents. You can optionally pass in a mimeType to be used for this blob.\n\t\t\t *\n\t\t\t * If a FileWriter was provided, the promise is resolved with null as the first argument.\n\t\t\t */\n\t\t\tthis.complete = function (mimeType) {\n\t\t\t\tif (fd || fileWriter) {\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// After writes complete we need to merge the buffer to give to the caller\n\t\t\t\t\twritePromise = writePromise.then(function () {\n\t\t\t\t\t\tlet\n\t\t\t\t\t\t\tresult = [];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (let i = 0; i < buffer.length; i++) {\n\t\t\t\t\t\t\tresult.push(buffer[i].data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn new Blob(result, {type: mimeType});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn writePromise;\n\t\t\t};\n\t\t};\n\t};\n\t\n\tif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\t\tmodule.exports = BlobBuffer;\n\t} else {\n\t\twindow.BlobBuffer = BlobBuffer(null);\n\t}\n})();\n", "module.exports = require(\"./WebMWriter\")(require(\"./ArrayBufferDataStream\"), require(\"./BlobBuffer\")(null));"],
  "mappings": "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",
  "names": ["buffer"]
}
