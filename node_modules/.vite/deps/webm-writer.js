import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/WebMWriter.js
var require_WebMWriter = __commonJS({
  "node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/WebMWriter.js"(exports, module) {
    "use strict";
    (function() {
      function extend(base, top) {
        let target = {};
        [base, top].forEach(function(obj) {
          for (let prop in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
              target[prop] = obj[prop];
            }
          }
        });
        return target;
      }
      function decodeBase64WebPDataURL(url) {
        if (typeof url !== "string" || !url.match(/^data:image\/webp;base64,/i)) {
          throw new Error("Failed to decode WebP Base64 URL");
        }
        return window.atob(url.substring("data:image/webp;base64,".length));
      }
      function renderAsWebP(canvas, quality) {
        let frame = typeof canvas === "string" && /^data:image\/webp/.test(canvas) ? canvas : canvas.toDataURL("image/webp", quality);
        return decodeBase64WebPDataURL(frame);
      }
      function byteStringToUint32LE(string) {
        let a = string.charCodeAt(0), b = string.charCodeAt(1), c = string.charCodeAt(2), d = string.charCodeAt(3);
        return (a | b << 8 | c << 16 | d << 24) >>> 0;
      }
      function extractKeyframeFromWebP(webP) {
        let cursor = webP.indexOf("VP8", 12);
        if (cursor === -1) {
          throw new Error("Bad image format, does this browser support WebP?");
        }
        let hasAlpha = false;
        while (cursor < webP.length - 8) {
          let chunkLength, fourCC;
          fourCC = webP.substring(cursor, cursor + 4);
          cursor += 4;
          chunkLength = byteStringToUint32LE(webP.substring(cursor, cursor + 4));
          cursor += 4;
          switch (fourCC) {
            case "VP8 ":
              return {
                frame: webP.substring(cursor, cursor + chunkLength),
                hasAlpha
              };
            case "ALPH":
              hasAlpha = true;
              break;
          }
          cursor += chunkLength;
          if ((chunkLength & 1) !== 0) {
            cursor++;
          }
        }
        throw new Error("Failed to find VP8 keyframe in WebP image, is this image mistakenly encoded in the Lossless WebP format?");
      }
      const EBML_SIZE_UNKNOWN = -1, EBML_SIZE_UNKNOWN_5_BYTES = -2;
      function EBMLFloat32(value) {
        this.value = value;
      }
      function EBMLFloat64(value) {
        this.value = value;
      }
      function writeEBML(buffer, bufferFileOffset, ebml) {
        if (Array.isArray(ebml)) {
          for (let i = 0; i < ebml.length; i++) {
            writeEBML(buffer, bufferFileOffset, ebml[i]);
          }
        } else if (typeof ebml === "string") {
          buffer.writeString(ebml);
        } else if (ebml instanceof Uint8Array) {
          buffer.writeBytes(ebml);
        } else if (ebml.id) {
          ebml.offset = buffer.pos + bufferFileOffset;
          buffer.writeUnsignedIntBE(ebml.id);
          if (Array.isArray(ebml.data)) {
            let sizePos, dataBegin, dataEnd;
            if (ebml.size === EBML_SIZE_UNKNOWN) {
              buffer.writeByte(255);
            } else if (ebml.size === EBML_SIZE_UNKNOWN_5_BYTES) {
              sizePos = buffer.pos;
              buffer.writeBytes([15, 255, 255, 255, 255]);
            } else {
              sizePos = buffer.pos;
              buffer.writeBytes([0, 0, 0, 0]);
            }
            dataBegin = buffer.pos;
            ebml.dataOffset = dataBegin + bufferFileOffset;
            writeEBML(buffer, bufferFileOffset, ebml.data);
            if (ebml.size !== EBML_SIZE_UNKNOWN && ebml.size !== EBML_SIZE_UNKNOWN_5_BYTES) {
              dataEnd = buffer.pos;
              ebml.size = dataEnd - dataBegin;
              buffer.seek(sizePos);
              buffer.writeEBMLVarIntWidth(ebml.size, 4);
              buffer.seek(dataEnd);
            }
          } else if (typeof ebml.data === "string") {
            buffer.writeEBMLVarInt(ebml.data.length);
            ebml.dataOffset = buffer.pos + bufferFileOffset;
            buffer.writeString(ebml.data);
          } else if (typeof ebml.data === "number") {
            if (!ebml.size) {
              ebml.size = buffer.measureUnsignedInt(ebml.data);
            }
            buffer.writeEBMLVarInt(ebml.size);
            ebml.dataOffset = buffer.pos + bufferFileOffset;
            buffer.writeUnsignedIntBE(ebml.data, ebml.size);
          } else if (ebml.data instanceof EBMLFloat64) {
            buffer.writeEBMLVarInt(8);
            ebml.dataOffset = buffer.pos + bufferFileOffset;
            buffer.writeDoubleBE(ebml.data.value);
          } else if (ebml.data instanceof EBMLFloat32) {
            buffer.writeEBMLVarInt(4);
            ebml.dataOffset = buffer.pos + bufferFileOffset;
            buffer.writeFloatBE(ebml.data.value);
          } else if (ebml.data instanceof Uint8Array) {
            buffer.writeEBMLVarInt(ebml.data.byteLength);
            ebml.dataOffset = buffer.pos + bufferFileOffset;
            buffer.writeBytes(ebml.data);
          } else {
            throw new Error("Bad EBML datatype " + typeof ebml.data);
          }
        } else {
          throw new Error("Bad EBML datatype " + typeof ebml.data);
        }
      }
      let WebMWriter = function(ArrayBufferDataStream, BlobBuffer) {
        return function(options) {
          let MAX_CLUSTER_DURATION_MSEC = 5e3, DEFAULT_TRACK_NUMBER = 1, writtenHeader = false, videoWidth = 0, videoHeight = 0, alphaBuffer = null, alphaBufferContext = null, alphaBufferData = null, clusterFrameBuffer = [], clusterStartTime = 0, clusterDuration = 0, optionDefaults = {
            quality: 0.95,
            // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (WebP lossless) is not supported
            transparent: false,
            // True if an alpha channel should be included in the video
            alphaQuality: void 0,
            // Allows you to set the quality level of the alpha channel separately.
            // If not specified this defaults to the same value as `quality`.
            fileWriter: null,
            // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)
            fd: null,
            // Node.JS file descriptor to write to instead of buffering (optional)
            // You must supply one of:
            frameDuration: null,
            // Duration of frames in milliseconds
            frameRate: null
            // Number of frames per second
          }, seekPoints = {
            Cues: { id: new Uint8Array([28, 83, 187, 107]), positionEBML: null },
            SegmentInfo: { id: new Uint8Array([21, 73, 169, 102]), positionEBML: null },
            Tracks: { id: new Uint8Array([22, 84, 174, 107]), positionEBML: null }
          }, ebmlSegment, segmentDuration = {
            "id": 17545,
            // Duration
            "data": new EBMLFloat64(0)
          }, seekHead, cues = [], blobBuffer = new BlobBuffer(options.fileWriter || options.fd);
          function fileOffsetToSegmentRelative(fileOffset) {
            return fileOffset - ebmlSegment.dataOffset;
          }
          function convertAlphaToGrayscaleImage(source) {
            if (alphaBuffer === null || alphaBuffer.width !== source.width || alphaBuffer.height !== source.height) {
              alphaBuffer = document.createElement("canvas");
              alphaBuffer.width = source.width;
              alphaBuffer.height = source.height;
              alphaBufferContext = alphaBuffer.getContext("2d");
              alphaBufferData = alphaBufferContext.createImageData(alphaBuffer.width, alphaBuffer.height);
            }
            let sourceContext = source.getContext("2d"), sourceData = sourceContext.getImageData(0, 0, source.width, source.height).data, destData = alphaBufferData.data, dstCursor = 0, srcEnd = source.width * source.height * 4;
            for (let srcCursor = 3; srcCursor < srcEnd; srcCursor += 4) {
              let alpha = sourceData[srcCursor];
              destData[dstCursor++] = alpha;
              destData[dstCursor++] = alpha;
              destData[dstCursor++] = alpha;
              destData[dstCursor++] = 255;
            }
            alphaBufferContext.putImageData(alphaBufferData, 0, 0);
            return alphaBuffer;
          }
          function createSeekHead() {
            let seekPositionEBMLTemplate = {
              "id": 21420,
              // SeekPosition
              "size": 5,
              // Allows for 32GB video files
              "data": 0
              // We'll overwrite this when the file is complete
            }, result = {
              "id": 290298740,
              // SeekHead
              "data": []
            };
            for (let name in seekPoints) {
              let seekPoint = seekPoints[name];
              seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);
              result.data.push({
                "id": 19899,
                // Seek
                "data": [
                  {
                    "id": 21419,
                    // SeekID
                    "data": seekPoint.id
                  },
                  seekPoint.positionEBML
                ]
              });
            }
            return result;
          }
          function writeHeader() {
            seekHead = createSeekHead();
            let ebmlHeader = {
              "id": 440786851,
              // EBML
              "data": [
                {
                  "id": 17030,
                  // EBMLVersion
                  "data": 1
                },
                {
                  "id": 17143,
                  // EBMLReadVersion
                  "data": 1
                },
                {
                  "id": 17138,
                  // EBMLMaxIDLength
                  "data": 4
                },
                {
                  "id": 17139,
                  // EBMLMaxSizeLength
                  "data": 8
                },
                {
                  "id": 17026,
                  // DocType
                  "data": "webm"
                },
                {
                  "id": 17031,
                  // DocTypeVersion
                  "data": 2
                },
                {
                  "id": 17029,
                  // DocTypeReadVersion
                  "data": 2
                }
              ]
            }, segmentInfo = {
              "id": 357149030,
              // Info
              "data": [
                {
                  "id": 2807729,
                  // TimecodeScale
                  "data": 1e6
                  // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)
                },
                {
                  "id": 19840,
                  // MuxingApp
                  "data": "webm-writer-js"
                },
                {
                  "id": 22337,
                  // WritingApp
                  "data": "webm-writer-js"
                },
                segmentDuration
                // To be filled in later
              ]
            }, videoProperties = [
              {
                "id": 176,
                // PixelWidth
                "data": videoWidth
              },
              {
                "id": 186,
                // PixelHeight
                "data": videoHeight
              }
            ];
            if (options.transparent) {
              videoProperties.push(
                {
                  "id": 21440,
                  // AlphaMode
                  "data": 1
                }
              );
            }
            let tracks = {
              "id": 374648427,
              // Tracks
              "data": [
                {
                  "id": 174,
                  // TrackEntry
                  "data": [
                    {
                      "id": 215,
                      // TrackNumber
                      "data": DEFAULT_TRACK_NUMBER
                    },
                    {
                      "id": 29637,
                      // TrackUID
                      "data": DEFAULT_TRACK_NUMBER
                    },
                    {
                      "id": 156,
                      // FlagLacing
                      "data": 0
                    },
                    {
                      "id": 2274716,
                      // Language
                      "data": "und"
                    },
                    {
                      "id": 134,
                      // CodecID
                      "data": "V_VP8"
                    },
                    {
                      "id": 2459272,
                      // CodecName
                      "data": "VP8"
                    },
                    {
                      "id": 131,
                      // TrackType
                      "data": 1
                    },
                    {
                      "id": 224,
                      // Video
                      "data": videoProperties
                    }
                  ]
                }
              ]
            };
            ebmlSegment = {
              "id": 408125543,
              // Segment
              "size": EBML_SIZE_UNKNOWN_5_BYTES,
              // We'll seek back and fill this in at completion
              "data": [
                seekHead,
                segmentInfo,
                tracks
              ]
            };
            let bufferStream = new ArrayBufferDataStream(256);
            writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);
            blobBuffer.write(bufferStream.getAsDataArray());
            seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);
            seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);
            writtenHeader = true;
          }
          function createBlockGroupForTransparentKeyframe(keyframe) {
            let block, blockAdditions, bufferStream = new ArrayBufferDataStream(1 + 2 + 1);
            if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {
              throw new Error("TrackNumber must be > 0 and < 127");
            }
            bufferStream.writeEBMLVarInt(keyframe.trackNumber);
            bufferStream.writeU16BE(keyframe.timecode);
            bufferStream.writeByte(0);
            block = {
              "id": 161,
              // Block
              "data": [
                bufferStream.getAsDataArray(),
                keyframe.frame
              ]
            };
            blockAdditions = {
              "id": 30113,
              // BlockAdditions
              "data": [
                {
                  "id": 166,
                  // BlockMore
                  "data": [
                    {
                      "id": 238,
                      // BlockAddID
                      "data": 1
                      // Means "BlockAdditional has a codec-defined meaning, pass it to the codec"
                    },
                    {
                      "id": 165,
                      // BlockAdditional
                      "data": keyframe.alpha
                      // The actual alpha channel image
                    }
                  ]
                }
              ]
            };
            return {
              "id": 160,
              // BlockGroup
              "data": [
                block,
                blockAdditions
              ]
            };
          }
          function createSimpleBlockForKeyframe(keyframe) {
            let bufferStream = new ArrayBufferDataStream(1 + 2 + 1);
            if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {
              throw new Error("TrackNumber must be > 0 and < 127");
            }
            bufferStream.writeEBMLVarInt(keyframe.trackNumber);
            bufferStream.writeU16BE(keyframe.timecode);
            bufferStream.writeByte(
              1 << 7
              // Keyframe
            );
            return {
              "id": 163,
              // SimpleBlock
              "data": [
                bufferStream.getAsDataArray(),
                keyframe.frame
              ]
            };
          }
          function createContainerForKeyframe(keyframe) {
            if (keyframe.alpha) {
              return createBlockGroupForTransparentKeyframe(keyframe);
            }
            return createSimpleBlockForKeyframe(keyframe);
          }
          function createCluster(cluster) {
            return {
              "id": 524531317,
              "data": [
                {
                  "id": 231,
                  // Timecode
                  "data": Math.round(cluster.timecode)
                }
              ]
            };
          }
          function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {
            cues.push({
              "id": 187,
              // Cue
              "data": [
                {
                  "id": 179,
                  // CueTime
                  "data": clusterTime
                },
                {
                  "id": 183,
                  // CueTrackPositions
                  "data": [
                    {
                      "id": 247,
                      // CueTrack
                      "data": trackIndex
                    },
                    {
                      "id": 241,
                      // CueClusterPosition
                      "data": fileOffsetToSegmentRelative(clusterFileOffset)
                    }
                  ]
                }
              ]
            });
          }
          function writeCues() {
            let ebml = {
              "id": 475249515,
              "data": cues
            }, cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32);
            writeEBML(cuesBuffer, blobBuffer.pos, ebml);
            blobBuffer.write(cuesBuffer.getAsDataArray());
            seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);
          }
          function flushClusterFrameBuffer() {
            if (clusterFrameBuffer.length === 0) {
              return;
            }
            let rawImageSize = 0;
            for (let i = 0; i < clusterFrameBuffer.length; i++) {
              rawImageSize += clusterFrameBuffer[i].frame.length + (clusterFrameBuffer[i].alpha ? clusterFrameBuffer[i].alpha.length : 0);
            }
            let buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 64), cluster = createCluster({
              timecode: Math.round(clusterStartTime)
            });
            for (let i = 0; i < clusterFrameBuffer.length; i++) {
              cluster.data.push(createContainerForKeyframe(clusterFrameBuffer[i]));
            }
            writeEBML(buffer, blobBuffer.pos, cluster);
            blobBuffer.write(buffer.getAsDataArray());
            addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);
            clusterFrameBuffer = [];
            clusterStartTime += clusterDuration;
            clusterDuration = 0;
          }
          function validateOptions() {
            if (!options.frameDuration) {
              if (options.frameRate) {
                options.frameDuration = 1e3 / options.frameRate;
              } else {
                throw new Error("Missing required frameDuration or frameRate setting");
              }
            }
            options.quality = Math.max(Math.min(options.quality, 0.99999), 0);
            if (options.alphaQuality === void 0) {
              options.alphaQuality = options.quality;
            } else {
              options.alphaQuality = Math.max(Math.min(options.alphaQuality, 0.99999), 0);
            }
          }
          function addFrameToCluster(frame) {
            frame.trackNumber = DEFAULT_TRACK_NUMBER;
            frame.timecode = Math.round(clusterDuration);
            clusterFrameBuffer.push(frame);
            clusterDuration += frame.duration;
            if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {
              flushClusterFrameBuffer();
            }
          }
          function rewriteSeekHead() {
            let seekHeadBuffer = new ArrayBufferDataStream(seekHead.size), oldPos = blobBuffer.pos;
            writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data);
            blobBuffer.seek(seekHead.dataOffset);
            blobBuffer.write(seekHeadBuffer.getAsDataArray());
            blobBuffer.seek(oldPos);
          }
          function rewriteDuration() {
            let buffer = new ArrayBufferDataStream(8), oldPos = blobBuffer.pos;
            buffer.writeDoubleBE(clusterStartTime);
            blobBuffer.seek(segmentDuration.dataOffset);
            blobBuffer.write(buffer.getAsDataArray());
            blobBuffer.seek(oldPos);
          }
          function rewriteSegmentLength() {
            let buffer = new ArrayBufferDataStream(10), oldPos = blobBuffer.pos;
            buffer.writeUnsignedIntBE(ebmlSegment.id);
            buffer.writeEBMLVarIntWidth(blobBuffer.pos - ebmlSegment.dataOffset, 5);
            blobBuffer.seek(ebmlSegment.offset);
            blobBuffer.write(buffer.getAsDataArray());
            blobBuffer.seek(oldPos);
          }
          this.addFrame = function(frame, alpha, overrideFrameDuration) {
            if (!writtenHeader) {
              videoWidth = frame.width || 0;
              videoHeight = frame.height || 0;
              writeHeader();
            }
            let keyframe = extractKeyframeFromWebP(renderAsWebP(frame, options.quality)), frameDuration, frameAlpha = null;
            if (overrideFrameDuration) {
              frameDuration = overrideFrameDuration;
            } else if (typeof alpha == "number") {
              frameDuration = alpha;
            } else {
              frameDuration = options.frameDuration;
            }
            if (options.transparent) {
              if (alpha instanceof HTMLCanvasElement || typeof alpha === "string") {
                frameAlpha = alpha;
              } else if (keyframe.hasAlpha) {
                frameAlpha = convertAlphaToGrayscaleImage(frame);
              }
            }
            addFrameToCluster({
              frame: keyframe.frame,
              duration: frameDuration,
              alpha: frameAlpha ? extractKeyframeFromWebP(renderAsWebP(frameAlpha, options.alphaQuality)).frame : null
            });
          };
          this.complete = function() {
            if (!writtenHeader) {
              writeHeader();
            }
            flushClusterFrameBuffer();
            writeCues();
            rewriteSeekHead();
            rewriteDuration();
            rewriteSegmentLength();
            return blobBuffer.complete("video/webm");
          };
          this.getWrittenSize = function() {
            return blobBuffer.length;
          };
          options = extend(optionDefaults, options || {});
          validateOptions();
        };
      };
      if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
        module.exports = WebMWriter;
      } else {
        window.WebMWriter = WebMWriter(window.ArrayBufferDataStream, window.BlobBuffer);
      }
    })();
  }
});

// node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/ArrayBufferDataStream.js
var require_ArrayBufferDataStream = __commonJS({
  "node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/ArrayBufferDataStream.js"(exports, module) {
    "use strict";
    (function() {
      let ArrayBufferDataStream = function(length) {
        this.data = new Uint8Array(length);
        this.pos = 0;
      };
      ArrayBufferDataStream.prototype.seek = function(toOffset) {
        this.pos = toOffset;
      };
      ArrayBufferDataStream.prototype.writeBytes = function(arr) {
        for (let i = 0; i < arr.length; i++) {
          this.data[this.pos++] = arr[i];
        }
      };
      ArrayBufferDataStream.prototype.writeByte = function(b) {
        this.data[this.pos++] = b;
      };
      ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;
      ArrayBufferDataStream.prototype.writeU16BE = function(u) {
        this.data[this.pos++] = u >> 8;
        this.data[this.pos++] = u;
      };
      ArrayBufferDataStream.prototype.writeDoubleBE = function(d) {
        let bytes = new Uint8Array(new Float64Array([d]).buffer);
        for (let i = bytes.length - 1; i >= 0; i--) {
          this.writeByte(bytes[i]);
        }
      };
      ArrayBufferDataStream.prototype.writeFloatBE = function(d) {
        let bytes = new Uint8Array(new Float32Array([d]).buffer);
        for (let i = bytes.length - 1; i >= 0; i--) {
          this.writeByte(bytes[i]);
        }
      };
      ArrayBufferDataStream.prototype.writeString = function(s) {
        for (let i = 0; i < s.length; i++) {
          this.data[this.pos++] = s.charCodeAt(i);
        }
      };
      ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function(i, width) {
        switch (width) {
          case 1:
            this.writeU8(1 << 7 | i);
            break;
          case 2:
            this.writeU8(1 << 6 | i >> 8);
            this.writeU8(i);
            break;
          case 3:
            this.writeU8(1 << 5 | i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          case 4:
            this.writeU8(1 << 4 | i >> 24);
            this.writeU8(i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          case 5:
            this.writeU8(1 << 3 | i / 4294967296 & 7);
            this.writeU8(i >> 24);
            this.writeU8(i >> 16);
            this.writeU8(i >> 8);
            this.writeU8(i);
            break;
          default:
            throw new Error("Bad EBML VINT size " + width);
        }
      };
      ArrayBufferDataStream.prototype.measureEBMLVarInt = function(val) {
        if (val < (1 << 7) - 1) {
          return 1;
        } else if (val < (1 << 14) - 1) {
          return 2;
        } else if (val < (1 << 21) - 1) {
          return 3;
        } else if (val < (1 << 28) - 1) {
          return 4;
        } else if (val < 34359738367) {
          return 5;
        } else {
          throw new Error("EBML VINT size not supported " + val);
        }
      };
      ArrayBufferDataStream.prototype.writeEBMLVarInt = function(i) {
        this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));
      };
      ArrayBufferDataStream.prototype.writeUnsignedIntBE = function(u, width) {
        if (width === void 0) {
          width = this.measureUnsignedInt(u);
        }
        switch (width) {
          case 5:
            this.writeU8(Math.floor(u / 4294967296));
          // Need to use division to access >32 bits of floating point var
          case 4:
            this.writeU8(u >> 24);
          case 3:
            this.writeU8(u >> 16);
          case 2:
            this.writeU8(u >> 8);
          case 1:
            this.writeU8(u);
            break;
          default:
            throw new Error("Bad UINT size " + width);
        }
      };
      ArrayBufferDataStream.prototype.measureUnsignedInt = function(val) {
        if (val < 1 << 8) {
          return 1;
        } else if (val < 1 << 16) {
          return 2;
        } else if (val < 1 << 24) {
          return 3;
        } else if (val < 4294967296) {
          return 4;
        } else {
          return 5;
        }
      };
      ArrayBufferDataStream.prototype.getAsDataArray = function() {
        if (this.pos < this.data.byteLength) {
          return this.data.subarray(0, this.pos);
        } else if (this.pos == this.data.byteLength) {
          return this.data;
        } else {
          throw new Error("ArrayBufferDataStream's pos lies beyond end of buffer");
        }
      };
      if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
        module.exports = ArrayBufferDataStream;
      } else {
        window.ArrayBufferDataStream = ArrayBufferDataStream;
      }
    })();
  }
});

// node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/BlobBuffer.js
var require_BlobBuffer = __commonJS({
  "node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/BlobBuffer.js"(exports, module) {
    "use strict";
    (function() {
      let BlobBuffer = function(fs) {
        return function(destination) {
          let buffer = [], writePromise = Promise.resolve(), fileWriter = null, fd = null;
          if (destination && destination.constructor.name === "FileWriter") {
            fileWriter = destination;
          } else if (fs && destination) {
            fd = destination;
          }
          this.pos = 0;
          this.length = 0;
          function readBlobAsBuffer(blob) {
            return new Promise(function(resolve, reject) {
              let reader = new FileReader();
              reader.addEventListener("loadend", function() {
                resolve(reader.result);
              });
              reader.readAsArrayBuffer(blob);
            });
          }
          function convertToUint8Array(thing) {
            return new Promise(function(resolve, reject) {
              if (thing instanceof Uint8Array) {
                resolve(thing);
              } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {
                resolve(new Uint8Array(thing));
              } else if (thing instanceof Blob) {
                resolve(readBlobAsBuffer(thing).then(function(buffer2) {
                  return new Uint8Array(buffer2);
                }));
              } else {
                resolve(readBlobAsBuffer(new Blob([thing])).then(function(buffer2) {
                  return new Uint8Array(buffer2);
                }));
              }
            });
          }
          function measureData(data) {
            let result = data.byteLength || data.length || data.size;
            if (!Number.isInteger(result)) {
              throw new Error("Failed to determine size of element");
            }
            return result;
          }
          this.seek = function(offset) {
            if (offset < 0) {
              throw new Error("Offset may not be negative");
            }
            if (isNaN(offset)) {
              throw new Error("Offset may not be NaN");
            }
            if (offset > this.length) {
              throw new Error("Seeking beyond the end of file is not allowed");
            }
            this.pos = offset;
          };
          this.write = function(data) {
            let newEntry = {
              offset: this.pos,
              data,
              length: measureData(data)
            }, isAppend = newEntry.offset >= this.length;
            this.pos += newEntry.length;
            this.length = Math.max(this.length, this.pos);
            writePromise = writePromise.then(function() {
              if (fd) {
                return new Promise(function(resolve, reject) {
                  convertToUint8Array(newEntry.data).then(function(dataArray) {
                    let totalWritten = 0, buffer2 = Buffer.from(dataArray.buffer), handleWriteComplete = function(err, written, buffer3) {
                      totalWritten += written;
                      if (totalWritten >= buffer3.length) {
                        resolve();
                      } else {
                        fs.write(fd, buffer3, totalWritten, buffer3.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);
                      }
                    };
                    fs.write(fd, buffer2, 0, buffer2.length, newEntry.offset, handleWriteComplete);
                  });
                });
              } else if (fileWriter) {
                return new Promise(function(resolve, reject) {
                  fileWriter.onwriteend = resolve;
                  fileWriter.seek(newEntry.offset);
                  fileWriter.write(new Blob([newEntry.data]));
                });
              } else if (!isAppend) {
                for (let i = 0; i < buffer.length; i++) {
                  let entry = buffer[i];
                  if (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {
                    if (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {
                      throw new Error("Overwrite crosses blob boundaries");
                    }
                    if (newEntry.offset == entry.offset && newEntry.length == entry.length) {
                      entry.data = newEntry.data;
                      return;
                    } else {
                      return convertToUint8Array(entry.data).then(function(entryArray) {
                        entry.data = entryArray;
                        return convertToUint8Array(newEntry.data);
                      }).then(function(newEntryArray) {
                        newEntry.data = newEntryArray;
                        entry.data.set(newEntry.data, newEntry.offset - entry.offset);
                      });
                    }
                  }
                }
              }
              buffer.push(newEntry);
            });
          };
          this.complete = function(mimeType) {
            if (fd || fileWriter) {
              writePromise = writePromise.then(function() {
                return null;
              });
            } else {
              writePromise = writePromise.then(function() {
                let result = [];
                for (let i = 0; i < buffer.length; i++) {
                  result.push(buffer[i].data);
                }
                return new Blob(result, { type: mimeType });
              });
            }
            return writePromise;
          };
        };
      };
      if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
        module.exports = BlobBuffer;
      } else {
        window.BlobBuffer = BlobBuffer(null);
      }
    })();
  }
});

// node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/webm-writer@1.0.0/node_modules/webm-writer/browser.js"(exports, module) {
    module.exports = require_WebMWriter()(require_ArrayBufferDataStream(), require_BlobBuffer()(null));
  }
});
export default require_browser();
//# sourceMappingURL=webm-writer.js.map
